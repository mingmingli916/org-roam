:PROPERTIES:
:ID:       4760711D-E0E8-489D-8395-F54C744EECC3
:END:
#+title: String Type

[[id:69AD65EC-8ADE-4490-B65A-9D942BE13C2C][Character Type]]

[[id:59D49734-498A-4282-9814-AC22B1D5A2EB][Array Type]]

A string is an array that contains an ordered sequence of characters.
A string is a fixed sequence of characters. It is a type of sequence called a array, meaning that its length is fixed and cannot be altered once it is created.
Strings cannot hold characters that have the hyper, super or alt modifiers; they can hold ASCII control characters, but no other control characters.
They do not distinguish case in ASCII control characters.

* Syntax for Strings

The read syntax for a string is a double-quote, an arbitrary number of
characters, and another double-quote (="like this."=). To include a
double-quote in a string, precede it with a backslash (="\""=).
Likewise, you can include a backslash by preceding it with another
backslash (="\\"=).

The newline character is not special in the read syntax for strings; if
you write a new line between the double-quotes, it becomes a character
in the string. But an escaped newline --- one that is preceded by
'\'---does not become part of the string; i.e., the Lisp reader ignores
an escaped newline while reading a string. An escaped space '\ ' is
likewise ignored.

* Non-ASCII Characters in Strings

There are two text representations for non-ASCII characters in Emacs
strings:

- multibyte\\
  Its value maybe between 0 and 4194303 (\(2^{22}-1\)). It store raw
  bytes.

- unibyte\\
  Its value is between 0 and 255 (\(2^{8}-1\)). It store human-readable
  text.

In both cases, characters above 127 are non-ASCII.

You can include a non-ASCII character in a string constant by writing it
literally. Instead of writing a character literally into a multibyte
string, you can write it as its character code using an escape sequence.

* Nonprinting Characters in Strings

You can use the same backslash escape-sequences in a string constant as
in character literals (but do not use the question mark that begins a
character constant).

#+begin_src
"\t"                                    ; tab
"\C-a"                                  ; C-a
#+end_src

However, not all of the characters you can write with backslash
escape-sequences are valid in strings. The only control characters that
a string can hold are the ASCII control characters. Strings do not
distinguish case in ASCII control characters.

Properly speaking, strings cannot hold meta characters; but when a
string is to be used as a key sequence, there is a special convention
that provides a way to represent meta versions of ASCII characters in a
string. If you use the '\M-' syntax to indicate a meta character in a
string constant, this sets the \(2^{7}\) bit of the character in the
string. If the string is used in =define-key= or =lookup-key=, this
numeric code is translated into the equivalent meta character.

Strings cannot hold characters that have the hyper, super, or alt
modifiers.

* Text Properties in Strings

A string can hold properties for the characters it contains, in addition
to the characters themselves. This enables programs that copy text
between strings and buffers to copy the text's properties with no
special effort. Strings with text properties use a special read and
print syntax:

#+begin_src
#("characters" property-data...)
#+end_src

where =property-data= consists of zero or more elements, in groups of
three as follows:

#+begin_src
beg end plist
#+end_src

The elements =beg= and =end= are integers, and together specify a range
of indices in the string; =plist= is the property list for that range.
For example:

#+begin_src
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
#+end_src




* Predicates for Strings
:PROPERTIES:
:CUSTOM_ID: sec:predicates-strings
:END:
- =(stringp object)=\\
  This function returns =t= if =object= is a string, =nil= otherwise.

- =(string-or-null-p object)=\\
  This function returns =t= if =object= is a string or =nil=. It returns
  =nil= otherwise

- =(char-or-string-p object)=\\
  This function returns =t= if =object= is a string or a character
  (i.e., an integer), =nil= otherwise.

* Creating Strings
:PROPERTIES:
:CUSTOM_ID: sec:creating-strings
:END:
- =(make-string count character &optional multibyte)=\\
  This function returns a string made up of =count= repetitions of
  =character=. If =count= is negative, an error is signaled.

  #+begin_src
  (make-string 5 ?x)                      ; "xxxxx"
  #+end_src

  Normally, if =character= is an ASCII character, the result is a
  unibyte string. But if the optional argument =multibyte= is non-nil,
  the function will produce a multibyte string instead.

- =(string &rest characters)=\\
  This returns a string containing the characters =characters=.

  #+begin_src
  (string ?a ?b ?c)                       ; "abc"
  #+end_src

- =(substring string &optional start end)=\\
  This function returns a new string which consists of those characters
  from =string= in the range from (and including) the character at the
  index =start= up to (but excluding) the character at the index =end=.
  The first character is at index zero.

  If the characters copied from =string= have text properties, the
  properties are copied into the new string also

  #+begin_src
  (substring "abcdefg" 0 3)               ; "abc"
  (substring "abcdefg" -3 -1)             ; "ef"
  (substring "abcdefg" -3 nil)            ; "efg"
  (substring "abcdefg" 0)                 ; "abcdefg"
  #+end_src

- =(substring-no-properties string &optional start end=\\
  This works like =substring= but discards all text properties from the
  value.

- =(concat &rest sequences)=\\
  This function returns a string consisting of the characters in the
  arguments passed to it (along with their text properties, if any). The
  arguments may be strings, lists of numbers, or vectors of numbers;
  they are not themselves changed. If =concat= receives no arguments, it
  returns an empty string.

  #+begin_src
  (concat "abc" "-def")                   ; "abc-def"
  (concat "abc" (list 120 121) [122])     ; "abcxyz"
  (concat "abc" nil "-def")               ; "abc-def"
  (concat)                                ; ""
  #+end_src

- =(split-string string &optional separators omit-nulls trim)=\\
  This function splits =argument= into substrings based on the regular
  expression =separators=. Each match for =separators= defines a
  splitting point; the substrings between splitting points are made into
  a slit, which is returned.

  If =separators= is =nil= (or omitted), the default is the value of
  =split-string-default-separators= and the function behaves as if
  =omit-nulls= were =t=.

  If =omit-nulls= is =nil= (or omitted), the result contains null
  strings whenever there are two consecutive matches for separators, or
  a match is adjacent to the beginning or end of string. If =omit-nulls=
  is =t=, these null strings are omitted from the result.

  If the optional argument =trim= is non-=nil=, it should be a regular
  expression to match text to trim from the beginning and end of each
  substring. If trimming makes the substring empty, it is treated as
  null.

  #+begin_src
  (split-string " two words ")            ; ("two" "words")
  (split-string "  two words "
                split-string-default-separators) ; ("" "two" "words" "")
  (split-string "Soup is good food" "o")         ; ("S" "up is g" "" "d f" "" "d")
  (split-string "Soup is good food" "o" t)       ; ("S" "up is g" "d f" "d")
  (split-string "Soup is good food" "o+")        ; ("S" "up is g" "d f" "d")
  #+end_src

- =split-string-default-separators=\\
  The default value of separators for =split-string=.

- =(string-clean-whitespace string)=\\
  Clean up the whitespace in =string= by collapsing stretches of
  whitespace to a single space character, as well as removing all
  whitespace from the start and the end of =string=.
  =(string-trim-left string &optional regexp)=\\
  Remove the leading text that matches =regexp= from =string=.

- =(string-trim-right string &optional regexp)=

- =(string-trim string &optional trim-left trim-right)=\\
  Remove the leading text that matches =trim-left= and trailing text
  that matches =trim-right= from string.

- =(string-fill string length)=\\
  Attempt to Word-wrap =string= so that no lines are longer than
  =length=. Filling is done on whitespace boundaries only.

- =(string-limit string length &optional end coding-system)=\\
  If =string= is shorter than =length= characters, =string= is returned
  as is. Otherwise, return a substring of =string= consisting of the
  first =length= characters. If the optional =end= parameter is given,
  return a string of the =length= last characters instead.

  If =coding-system= is non-=nil=, =string= will be encoded before
  limiting.

- =(string-lines string &optional omit-nulls)=\\
  Split =string= into a list of strings on newline boundaries. If
  =omit-nulls=, remove empty lines from the results.

- =(string-pad string length &optional padding start)=\\
  Pad =string= to be of the given =length= using =padding= as the
  padding character. =padding= defaults to the space character. If
  =string= is longer than =length=, no padding is done. If =start= is
  =nil= or omitted, the padding is appended to the characters of
  =string=, and if it's non-=nil=, the padding is prepended to
  =string='s characters. =(string-chop-newline string)=\\
  Remove the final newline, if any, from =string=.

* Modifying Strings
:PROPERTIES:
:CUSTOM_ID: sec:modifying-strings
:END:
- =(aset string idx char)=\\
  This function stores =char= into =string= at character index =idx=.

- =(store-substring string idx obj)=\\
  This function alters part of the contents of the specified =string=,
  by storing =obj= starting at character index =idx=.

- =(clear-string string)=\\
  This makes =string= a unibyte string and clears its contents to zeros.
  It may also change =string='s length.

* Comparsion of Characters and Strings
:PROPERTIES:
:CUSTOM_ID: sec:comp-char-strings
:END:
- =(char-equal character1 character2)=\\
  This function returns =t= if the arguments represent the same
  character, =nil= otherwise. This function ignores differences in case
  if =case-fold-search= is non-=nil=.

- =(string= string1 string2)=\\
  This function returns =t= if the characters of the two strings match
  exactly. Symbols are also allowed as arguments, in which case the
  symbol names are used. Case is always significant, regardless of
  =case-fold-search=.

- =(string-equal string1 string2)=\\
  another name for =string==

- =(string-collate-equalp string1 string2 &optional locale ignore-case)=\\
  This function returns =t= if =string1= and =string2= are equal with
  respect to collation rules. A *collation rule* is not only determined
  by the lexicographic order of the characters contained in =string1=
  and =string2=, but also further rules about relations between these
  characters. Usually, it is defined by the =locale= environment Emacs
  is running with and by the Standard C library against which Emacs was
  linked.

  The optional argument =locale=, a string, overrides the setting of
  your current locale identifier for collation. The value is system
  dependent.

  If =ignore-case= is non-=nil=, characters are converted to lower-case
  before comparing them.

- =(string< string1 string2)=\\
  This function compares two strings a character at a time. It scans
  both the strings at the same time to find the first pair of
  corresponding characters that do not match. If the lesser character of
  these two is the character from =string1=, then =string1= is less, and
  this function returns =t=. If the lesser character is the one from
  =string2=, then =string1= is greater, and this function returns =nil=.
  If the two strings match entirely, the value is =nil=.

- =(string-lessp string1 string2)=\\
  another name for =string<=

- =(string-greaterp string1 string2)=\\
  This function returns the result of comparing =string1= and =string2=
  in the opposite order, i.e., it is equivalent to calling
  =(string-lessp string2 string1)=.

- =(string-collate-lessp string1 string2 &optional locale ignore-case)=\\
  This function returns =t= if =string1= is less than =string2= in
  collation order.

- =(string-version-lessp string1 string2)=\\
  This function compares strings lexicographically, except it treats
  sequences of numerical characters as if they comprised a base-ten
  number, and then compares the numbers. So 'foo2.png' is "smaller" than
  'foo12.png' according to this predicate, even if '12' is
  lexicographically "smaller" than '2'.

- =(string-prefix-p prefix string &optional ignore-case)=\\
  This function returns non-=nil= if =prefix= is a prefix of =string=.

- =(string-suffix-p suffix string &optional ignore-case)=\\
  This function returns non-=nil= if =suffix= is a suffix of =string=.

- =(compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case)=\\
  The strings are compared by the numeric values of their characters.

  If the specified portions of the two strings match, the value is =t=.
  Otherwise, the value is an integer which indicates how many leading
  characters agree, and which string is less. Its absolute value is one
  plus the number of characters that agree at the beginning of the two
  strings. The sign is negative if =string1= (or its specified portion)
  is less.

- =(string-distance string1 string2 &optional bytecompare)=\\
  This function returns the *Levenshtein distance* between the source
  string =string1= and the target string =string2=. The Levenshtein
  distance is the number of single character changes --- deletions,
  insertions, or replacements --- required to transform the source
  string into the target string; it is one possible definition of the
  edit distance between strings.

* Conversion of Characters and Strings
:PROPERTIES:
:CUSTOM_ID: sec:conv-char-strings
:END:
This section describes functions for converting between characters,
strings and integers.

- =(number-to-string number)=\\
  This function returns a string consisting of the printed base-ten
  representation of number.

- =(string-to-number string &optional base)=\\
  This function returns the numeric value of the characters in string.
  If =string= cannot be interpreted as a number, this function
  returns 0.

* Formatting Strings
:PROPERTIES:
:CUSTOM_ID: sec:formatting-strings
:END:
*Formatting* means constructing a string by substituting computed values
at various places in a constant string. This constant string controls
how the other values are printed, as well as where they appear; it is
called a *format string*.

- =(format string &rest objects)=\\
  This function returns a string equal to =string=, replacing any format
  specification with encodings of the corresponding =objects=. The
  argument =objects= are the computed values to be formatted.

  The characters in =string=, other than the format specifications, are
  copied directly into the output, including their text properties, if
  any. Any text properties of the format specifications are copied to
  the produced string representations of the argument =objects=.

  #+begin_src
  (format "hello, %s" "Ming")             ; "hello, Ming"
  #+end_src

- =(format-message string &rest objects)=\\
  This function acts like =format=, except it also converts any grave
  accents (') and apostrophes (') in string as per the value of
  =text-quoting-style=.

  #+begin_src
  (format "hello, '%s'" "Ming")           ; "hello, 'Ming'"
  (format-message "hello, '%s'" "Ming")   ; "hello, ’Ming’"
  #+end_src

A *format specification* is a sequence of characters beginning with a
=%=. Certain format specifications require values of particular types.
If you supply a value that doesn't fit the requirements, an error is
signaled.

Here is a list of valid format specifications:

- =%s=\\
  Replace the specification with the printed representation of the
  object, made without quoting.

- =%S=\\
  Replace the specification with the printed representation of the
  object, made with quoting.

  #+begin_src
  (format "%s" "hello")                   ; "hello"
  (format "%S" "hello")                   ; "\"hello\""
  #+end_src

- =%o=\\
  Replace the specification with the base-eight representation of an
  integer.

- =%d=\\
  Replace the specification with the base-ten representation of a signed
  integer.

- =%x=\\
  Replace the specification with the base-sixteen representation of an
  integer using lower case.

- =%X=\\
  Replace the specification with the base-sixteen representation of an
  integer using upper case.

- =%c=\\
  Replace the specification with the character which is the value given.

- =%e=\\
  Replace the specification with the exponential notation for a
  floating-point number.

- =%f=\\
  Replace the specification with the decimal-point notation for a
  floating-point number.

- =%g=\\
  Replace the specification with notation for a floating-point number,
  using either exponential notation or decimal-point notation.

- =%%=\\
  Replace the specification with a single =%=. This format specification
  is unusual in that its only form is plain =%%= and that it does not
  use a value.

  #+begin_src
  (format "%% %d" 30)                     ; "% 30"
  #+end_src

By default, format specifications correspond to successive values from
=objects=. Thus, the first format specification in string uses the first
such value, the second format specification uses the second such value,
and so on. Any extra format specifications (those for which there are no
corresponding values) cause an error. Any extra values to be formatted
are ignored.

A format specification can have a *field number*, which is a decimal
number immediately after the initial =%=, followed by a literal dollar
sign =$=. It causes the format specification to convert the argument
with the given number instead of the next argument. Field numbers start
at 1. A format can contain either numbered or unnumbered format
specifications but not both, except that =%%= can be mixed with numbered
specifications.

#+begin_src
(format "%2$s, %3$s, %%, %1$s" "x" "y" "z")
;;  "y, z, %, x"
#+end_src

After the =%= and any field number, you can put certain *flag
characters*.

- =+=\\
  Insert a plus sign before a nonnegative number. They are ignored
  except for =%d, %e, %f, %g=.

- =space character=\\
  Insert a space before a nonnegative number. They are ignored except
  for =%d, %e, %f, %g=. If both =+= and =space character= are used, =+=
  takes precedence.

- =#=\\
  Specifies an alternate form which depends on the format in use.

  - For =%o=, it ensures that the result begins with a =0=.

  - For =%x= and =%X=, it prefixes nonzero results with =0x= or =0X=.

  - For =%e= and =%f=, it include a decimal point even if the precision
    is zero.

  - For =%g=, it always includes a decimal point, and also forces any
    trailing zeros after the decimal point to be left in place where
    they would otherwise be removed.

- =0=\\
  Ensures that the padding consists of =0= characters instead of spaces.
  This flag is ignored for non-numerical specification characters like
  =%s=, =%S= and =%c=. These specification characters accept the =0=
  flag, but still pad with spaces.

- =-=\\
  Causes any padding inserted by the width, if specified, to be inserted
  on the right rather than the left. If both =-= and =0= are present,
  the =0= flag is ignored.

#+begin_src
(format "%06d is padded on the left with zeros" 123)
;;  "000123 is padded on the left with zeros"
(format "'%-6d' is padded on the right" 123)
;;  "'123   ' is padded on the right"
(format "The word '%-7s' actually has %d letters in it."
        "foo" (length "foo"))
;;  "The word 'foo    ' actually has 3 letters in it."
#+end_src

A specification can have a *width*, which is a decimal number that
appears after any field number and flags. If the printed representation
of the object contains fewer characters than this width, =format=
extends it with padding. Any padding introduced by the width normally
consists of spaces inserted on the left. If the width is too small,
format does not truncate the object's printed representation.

#+begin_src
(format "%5d is padded on the left with spaces" 123)
;;  "  123 is padded on the left with spaces"
(format "The word '%7s' has %d letters in it."
        "specification" (length "specification"))
;;  "The word 'specification' has 13 letters in it."
#+end_src

All the specification characters allow an optional *precision* after the
field number, flags and width, if present. The precision is a
decimal-point =.= followed by a digit-string.

- For the floating-point specifications (=%e= and =%f=), the precision
  specifies how many digits following the decimal point to show; if
  zero, the decimal-point itself is also omitted.

- For =%g=, the precision specifies how many significant digits to show
  (significant digits are the first digit before the decimal point and
  all the digits after it). If the precision of =%g= is zero or
  unspecified, it is treated as 1.

- For =%s= and =%S=, the precision truncates the string to the given
  width.

- For other specification characters, the effect of precision is what
  the local library functions of the =printf= family produce.

* Custom Format Strings
:PROPERTIES:
:CUSTOM_ID: sec:cust-form-strings
:END:
#+begin_src
(format-spec template spec-alist &optional ignore-missing split)
#+end_src

This function returns a string produced from the format string
=template= according to conversion specified in =spec-alist=, which is
an alist of the form =(letter . replacement)=. Each specification
=%letter= in =template= will be replaced by =replacement= when
formatting the resulting string.

Using an alist to specify conversions gives rise to some useful
properties:

- If =spec-alist= contains more unique =letter= keys than there are
  unique specification characters in =template=, the unused keys are
  ignored.

- If =spec-alist= contains more than one association with the same
  =letter=, the closest on to the start of the list is used.

- If =template= contains the same specification character more than
  once, then the same =replacement= found in =spec-alist= is used as a
  basis for all of that character's substitutions.

- The order of specification in =template= need not to correspond to the
  order of association in =spec-alist=.

The optional argument =ignore-missing= indicates how to handle
specification characters in template that are not found in =spec-alist=.
If it is =nil= or omitted, the function signals an error; if it is
=ignore=, those format specifications are left verbatim in the output,
including their text properties, if any; if it is =delete=, those format
specifications are removed from the output; any other non-=nil= value is
handled like ignore, but any occurrences of =%%= are also left verbatim
in the output.

If the optional argument =split= is non-=nil=, instead of returning a
single string, =format-spec= will split the result into a list of
strings, based on where the substitutions were performed.

#+begin_src
(format-spec "foo %b bar" '((?b . "zot")) nil t)
;; ("foo " "zot" " bar")
#+end_src

Unlike =format=, which assigns specific meanings to a fixed set of
specification characters, =format-spec= accepts arbitrary specification
characters and treats them all equally. For example:

#+begin_src

(setq my-site-info
      (list (cons ?s system-name)
            (cons ?t (symbol-name system-type))
            (cons ?c system-configuration)
            (cons ?v emacs-version)
            (cons ?e invocation-name)
            (cons ?p (number-to-string (emacs-pid)))
            (cons ?a user-mail-address)
            (cons ?n user-full-name)))

(format-spec "%e %v (%c) Emacs User: %n" my-site-info)
;; "Emacs-x86_64-10_14 28.2 (x86_64-apple-darwin18.7.0) Emacs User: Mingming Li"
#+end_src

A format specification can include any number of the following flag
characters immedi- ately after the =%=.

- =0=\\
  Causes any padding specified by the width to consist of =0= characters
  instead of spaces.

- =-=\\
  Causes any padding specified by the width to be inserted on the right
  rather than the left.

- =<=\\
  Causes the substitution to be truncated on the left to the given width
  and precision, if specified.

- =>=\\
  Causes the substitution to be truncated on the right to the given
  width, if specified.

- =^=\\
  Converts the substituted text to upper case.

- ^_\\
  Converts the substituted text to lower case.

As is the case with =format=, a format specification can include a
width, which is a decimal number that appears after any flags, and a
precision, which is a decimal-point =.= followed by a decimal number
that appears after any flags and width.

If a substitution contains fewer characters than its specified width, it
is padded on the left. If a substitution contains more characters than
its specified precision, it is truncated on the right.

#+begin_src
(setq my-battery-info
      (list (cons ?p "73")      ; Percentage
            (cons ?L "Battery") ; Status
            (cons ?t "2:23")    ; Remaining time
            (cons ?c "24330")   ; Capacity
            (cons ?r "10.6")))  ; Rate of discharge

(format-spec "%>^-3L : %3p%% (%05t left)" my-battery-info)
;; "BAT :  73% (02:23 left)"
#+end_src

* Case Conversion in Lisp
:PROPERTIES:
:CUSTOM_ID: sec:case-conversion-lisp
:END:
The character case functions change the case of single characters or of
the contents of strings. The functions normally convert only alphabetic
characters (the letters 'A' through 'Z' and 'a' through 'z', as well as
non-ASCII letters); other characters are not altered. You can specify a
different case conversion mapping by specifying a case table.

These functions do not modify the strings that are passed to them as
arguments.

- =(downcase string-or-char)=

- =(upcase string-or-char)=

- =(capitalize string-or-char)=

- =(upcase-initials string-or-char)=

#+begin_src
;; downcase
(downcase "The cat in the hat")         ; "the cat in the hat"
(downcase ?X)                           ; 120

;; upcase
(upcase "The cat in the hat")           ; "THE CAT IN THE HAT"
(upcase ?x)                             ; 88

;; capitalize
(capitalize "The cAt in the hat")       ; "The Cat In The Hat"
(capitalize ?x)                         ; 88

;; upcase-initials
(upcase-initials "The cAt in the hat")  ; "The CAt In The Hat"
(upcase-initials ?x)                    ; 88
#+end_src

* The Case Table
:PROPERTIES:
:CUSTOM_ID: sec:case-table
:END:
You can customize case conversion by installing a special *case table*.
A case table specifies the mapping between upper case and lower case
letters. It affects both the case conversion functions for Lisp objects
and those that apply to text in the buffer. Each buffer has a case
table; there is also a standard case table which is used to initialize
the case table of new buffers.

A case table is a char-table whose subtype is =case-table=. This
char-table maps each character into the corresponding lower case
character. It has three extra slots, which hold related tables:

- =upcase=\\
  The upcase table maps each character into the corresponding upper case
  character.

- =canonicalize=\\
  The canonicalize table maps all of a set of case-related characters
  into a particular member of that set.

- =equivalences=\\
  The equivalences table maps each one of a set of case-related
  characters into the next character in that set.

In simple cases, all you need to specify is the mapping to lower-case;
the three related tables will be calculated automatically from that one.

For some languages, upper and lower case letters are not in one-to-one
correspondence. There may be two different lower case letters with the
same upper case equivalent. In these cases, you need to specify the maps
for both lower case and upper case.

The extra table =canonicalize= maps each character to a canonical
equivalent; any two characters that are related by case-conversion have
the same canonical equivalent character. For example, since 'a' and 'A'
are related by case-conversion, they should have the same canonical
equivalent character (which should be either 'a' for both of them, or
'A' for both of them).

The extra table =equivalences= is a map that cyclically permutes each
equivalence class (of characters with the same canonical equivalent).
(For ordinary ASCII, this would map 'a' into 'A' and 'A' into 'a', and
likewise for each set of equivalent characters.)

When constructing a case table, you can provide =nil= for
=canonicalize=; then Emacs fills in this slot from the lower case and
upper case mappings. You can also provide =nil= for =equivalences=; then
Emacs fills in this slot from =canonicalize=. In a case table that is
actually in use, those components are non-=nil=.

