:PROPERTIES:
:ID:       74616282-7490-4D9D-8AE1-B39D8839AC9A
:END:
#+title: Lisp Data Types


[[id:90F7F822-E3F2-4E55-B918-027E9AD1C27B][Programming Types]]
[[id:DA82C254-C3DB-4114-9626-CFEFC150E5A3][Editing Types]]


A Lisp *object* is a piece of data used and manipulated by Lisp
programs. A *type* or *data type* is a set of possible objects.
A data type consists of data structure and the functions can be operated on this data structure.

Every object belongs to at least one type. Objects of the same type have
similar structures and may usually be used in the same contexts. Types
can overlap, and objects can belong to two or more types. Consequently,
we can ask whether an object belongs to a particular type, but not for
the type of an object. (This may differ from other programming language)

A few fundamental object types are built into Emacs. These, from which
all other types are constructed, are called *primitive types*. Each
object belongs to *one and only one* primitive type. These types include
*integer, float, cons, symbol, string, vector, hash-table, subr,
byte-code function*, and *record*, plus several special types, such as
*buffer*, that are related to editing.

Each primitive type has a corresponding Lisp function that checks
whether an object is a member of that type.

Lisp is unlike many other languages in that its objects are
*self-typing*: the primitive type of each object is *implicit* in the
object itself. For example, if an object is a vector, nothing can treat
it as a number; Lisp knows it is a vector, not a number.

In most languages (like Java), the programmer must declare the data type
of each variable, and the type is known by the compiler but not
represented in the data. Such type declarations do not exist in Emacs
Lisp. A Lisp variable can have any type of value, and it remembers
whatever value you store in it, type and all.

* Printed Representation and Read Syntax

The *printed representation* of an object is the format of the output
generated by the Lisp printer (the function *prin1*) for that object.
Every data type has a *unique* printed representation. The *read syntax*
of an object is the format of the input accepted by the Lisp reader (the
function *read*) for that object. This is not necessarily unique; many
kinds of object have more than one syntax.

In most cases, an object's printed representation is also a read syntax
for the object.

In other languages, an expression is text; it has no other form. In
Lisp, an expression is primarily a Lisp object and only secondarily the
text that is the object's read syntax.

* Special Read Syntax

Emacs Lisp represents many special objects and constructs via special
hash notations.

- *#<...>*\\
  Objects that have no read syntax are presented like this.

- *##*\\
  The printed representation of an interned symbol whose name is an
  empty string.

- *#\('\)*\\
  This is a shortcut for *function*.

- *#:*\\
  The printed representation of an uninterned symbol whose name is =foo=
  is =#:foo=.

- *#N*\\
  When printing circular structures, this construct is used to represent
  where the structure loops back onto itself, and 'N' is the starting
  list count:

  #+begin_example
  (let ((a (list 1)))
    (setcdr a a))
  ;; => (1 . #0)
  #+end_example

- *#N=*

- *#N#*\\
  *#N=* gives the name to an object and *#N#* represents that object, so
  when reading back the object, they will be the same object instead of
  copies.

- *#xN*\\
  'n' represented as a hexadecimal number (=#x2a=).

- *#oN*\\
  'N' represented as an octal number (=#o52=).

- *#bN*\\
  'N' represented as a binary number (=#b101010=).

- *#(...)*\\
  String text properties.

- *#^*\\
  A char table.

- *#s(hash-table ...)*\\
  A hash table.

- *?C*\\
  A character.

- *#$*\\
  The current file name in byte-compiled files.

- *#@N*\\
  Skip the next 'N' characters.

- *#f*\\
  Indicates that the following form isn't readable by the Emacs Lisp
  reader. This is only in text for display purposes and will never
  appear in any Lisp file.

* Read Syntax for Circular Objects

To represent shared or circular structures within a complex of Lisp
objects, you can use the reader constructs =#n== and =#n#=.

Use =#n== before an object to label it for later reference;
subsequently, you can use =#n#= to refer the same object in another
place. Here, =n= is some integer.

#+begin_example
;; make a list in which the first element recurs as the third element
(#1=(a) b #1#)

;; This differs from ordinary syntax such as this
((a) b (a))

(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))                ; t

(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))                ; nil
#+end_example

You can also use the same syntax to make a circular structure, which
appears as an element within itself.

#+begin_example
;; This makes a list whose second element is the list itself.
#1=(a #1#)
#+end_example

* Comments

A *comment* is text that is written in a program only for the sake of
humans that read the program, and that has no effect on the meaning of
the program. In Lisp, an unescaped semicolon (*;*) starts a comment if
it is not within a string or character constant. The comment continues
to the end of line.

* Programming Types and Editing Types

There are two general categories of types in Emacs Lisp:

- those having to do with Lisp programming. (exist in many Lisp
  implementation.) ([[id:90F7F822-E3F2-4E55-B918-027E9AD1C27B][Programming Types]])

- those having to do with editing. (unique to Emacs Lisp.) ([[id:DA82C254-C3DB-4114-9626-CFEFC150E5A3][Editing Types]])

Type in Emacs Lisp is like class in structure in C, class in Java and
Python.


* Type Predicates

The Emacs Lisp interpreter itself does not perform type checking on the
actual arguments passed to functions when they are called. It could not
do so, since function arguments in Lisp do not have declared data types,
as they do in other programming languages. It is therefore up to the
individual function to test whether each actual argument belongs to a
type that the function can use.

All built-in functions do check the types of their actual arguments when
appropriate, and signal a wrong-type-argument error if an argument is of
the wrong type.

If you want your program to handle different types differently, you must
do explicit type checking. The most common way to check the type of an
object is to call a *type predicate* function. Emacs has a type
predicate for each type, as well as some predicates for combinations of
types.

A type predicate function takes one argument; it returns t if the
argument belongs to the appropriate type, and nil otherwise. Following a
general Lisp convention for predicate functions, most type predicates'
names end with =p=.

Here is a table of predefined type predicates, in alphabetical order:

- atom

- arrayp

- bignump

- bool-vector-p

- booleanp

- bufferp

- byte-code--function-p

- case-table-p

- char-or-string-p

- char-table-p

- commandp

- condition-variable-p

- consp

- custom-variable-p

- fixnump

- floatp

- fontp

- frame-configuration-p

- frame-live-p

- framep

- functionp

- hash-table-p

- integer-or-marker-p

- integerp

- keymapp

- keywordp

- listp

- markerp

- mutexp

- nlistp

- number-or-marker-p

- numberp

- overlayp

- processp

- recordp

- sequencep

- string-or-null-p

- stringp

- subrp

- symbolp

- syntax-table-p

- treadp

- vectorp

- wholenump

- window-configuration-p

- window-live-p

- windowp

The most general way to check the type of an object is to call the
function =type-of=. Each object belongs to one and only one primitive
type; =type-of= tells you which one. But =type-of= knows nothing about
non-primitive types. In most cases, it is more convenient to use type
predicates than =type-of=.

* Type Descriptors

A *type descriptor* is a =record= which holds information about a type.
Slot 1 in the record must be a symbol naming the type, and =type-of=
relies on this to return the type of =record= objects. No other type
descriptor slot is used by Emacs; they are free for use by Lisp
extensions.

* Equality Predicates

Here we describe functions that test for equality between two objects.

- =(eq object1 object2)=\\
  This function returns =t= if =object1= and =object2= are the same
  object, and =nil= otherwise.

  - If =object1= and =object2= are symbols with the same name, they are
    normally the same object (there are exceptions[fn:1]).

  - For other non-numeric types (e.g., lists, vectors, strings), two
    arguments with the same contents or elements are not necessarily
    =eq= to each other: they are =eq= only if they are the same object,
    meaning that a change in the contents of one will be reflected by
    the same change in the contents of the other.

  - If =object1= and =object2= are numbers with differing types or
    values, then they cannot be the same object and =eq= returns =nil=.

  - If they are fixnums with the same value, then they are the same
    object and =eq= returns =t=.

  - If they were computed separately but happen to have the same value
    and the same non-fixnum numeric type, then they might or might not
    be the same object, and =eq= returns =t= or =nil= depending on
    whether the Lisp interpreter created one object or two.

- =(equal object1 object2)=\\
  This function returns t if object1 and object2 have equal components,
  and nil otherwise.

  Comparison of strings is case-sensitive, but does not take account of
  text properties --- it compares only the characters in the strings.

  The =equal= function recursively compares the contents of objects if
  they are inte gers, strings, markers, vectors, bool-vectors, byte-code
  function objects, char-tables, records, or font objects. Other objects
  are considered =equal= only if they are =eq=. For example, two
  distinct buffers are never considered equal, even if their textual
  contents are the same.

- =(equal-including-properties object1 object2)=\\
  This function behaves like =equal= in all cases but also requires that
  for two strings to be equal, they have the same text properties.

* Mutability

Some Lisp object should or can never change. But some Lisp objects can
change, we say they are *mutable*.

A mutable object stops being mutable if it is part of expression that is
evaluated.

