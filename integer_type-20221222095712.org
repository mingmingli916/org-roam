:PROPERTIES:
:ID:       8615D3F0-F0E7-4A7F-9597-BAD9F571CB28
:END:
#+title: Integer Type


There are two kinds of integers:

- small integers, called *fixnums*

- large integers, called *bignums*.

The range of values for a fixnum depends on the machine. The minimum
range is \(-2^{29}\) to \(2^{29}-1\) but many machines provide a wider
range. Bignums can have arbitrary precision. Operations that overflow a
fixnum will return a bignum instead.

All numbers can be compared with =eql= or ===; fixnums can also be
compared with =eq=. To test whether an integer is a fixnum or a bignum,
you can use predicates =fixnump= and =bignump=.

The read syntax for integers is a sequence of (base ten) digits with an
optional sign at the beginning and an optional period at the end. The
printed representation produced by the Lisp interpreter never has a
leading '+' or a final '.'.

#+begin_src
-1   ; -1
1    ; 1
1.   ; 1
+1   ; 1
#+end_src

The Lisp reader reads an integer as nonempty sequence of decimal digits
with optional initial sign and optional final period.

#+begin_src
1
1.
+1
-1
0
-0
#+end_src

The syntax for integers in bases other than 10 consists of =#= followed
by a radix indication followed by one or more digits.

#+begin_src
;; binary
#b101100                                ; 44
;; octal
#o54                                    ; 44
;; hex
#x2c                                    ; 44
;; #radix r integer, radix=24
#24r1k                                  ; 44
#+end_src

Many of the functions described in this chapter accept markers for
arguments in place of numbers. Since the actual arguments to such
functions may be either numbers or markers, we often give these
arguments the name =number-or-marker=. When the argument value is a
marker, its position value is used and its buffer is ignored.

In Emacs Lisp, text characters are represented by integers. Any integer
between zero and the value of =(max-char)=, inclusive, is considered to
be valid as a character.

Integers in Emacs Lisp are not limited to the machine word size. Under
the hood, though, there are two kinds of integers: smaller ones, called
*fixnums*, and larger ones, called *bignums*.

#+begin_src
most-positive-fixnum                    ; 2305843009213693951
most-negative-fixnum                    ; -2305843009213693952
;; Maximum number N of bits in safely-calculated integers.
integer-width                           ; 65536
#+end_src




* Bitwise Opeartions on Integers
:PROPERTIES:
:CUSTOM_ID: sec:bitw-opeart-iteg
:END:
The bitwise operations in Emacs Lisp apply only to integers.

- =(ash integer1 count)=
  
  =ash= (arithmetic shift) shifts the bits in =integer1= to the left
  =count= places, or to the right if =count= is negative. Left shifts
  introduce zero bits on the right; right shifts discard the rightmost
  bits.

- =(lsh integer1 count)=
  
  =lsh= (logical shift) shifts the bits in =integer1= to the left
  =count= places, or to the right if =count= is negative, bringing zeros
  into the vacated bits.

  #+begin_src
  ;; -7 = ...111111111111111111111111111001
  (ash -7 -1)                   ; -4 = ...111111111111111111111111111100
  (lsh -7 -1)           ; 536870908  = ...011111111111111111111111111100
  #+end_src

- =(logand &rest ints-or-markers)=
  
  This function returns the bitwise AND of the arguments: the nth bit is
  1 in the result if, and only if, the nth bit is 1 in all the
  arguments. If =logand= is not passed any argument, it returns a value
  of -1. This number is an identity element for =logand= because its
  binary representation consists entirely of ones. If =logand= is passed
  just one argument, it returns that argument.

- =(logior &rest ints-or-markers)=
  
  This function returns the bitwise inclusive OR of its arguments: the
  nth bit is 1 in the result if, and only if, the nth bit is 1 in at
  least one of the arguments. If there are no arguments, the result is
  0, which is an identity element for this operation. If =logior= is
  passed just one argument, it returns that argument.

- =(logxor &rest ints-or-markers)=
  
  This function returns the bitwise exclusive OR of its arguments: the
  nth bit is 1 in the result if, and only if, the nth bit is 1 in an odd
  number of the arguments. If there are no arguments, the result is 0,
  which is an identity element for this operation. If =logxor= is passed
  just one argument, it returns that argument.

- =(lognot integer)=
  
  This function returns the bitwise complement of its argument: the nth
  bit is one in the result if, and only if, the nth bit is zero in
  =integer=, and vice-versa.

- =(logcount integer)=
  
  This function returns the *Hamming weight* of =integer=: the number of
  ones in the binary representation of =integer=. If =integer= is
  negative, it returns the number of zero bits in its two's complement
  binary representation. The result is always nonnegative.

